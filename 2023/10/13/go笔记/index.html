<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>go笔记 | dany's blog</title><meta name="author" content="dany"><meta name="copyright" content="dany"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="知识点字符串由一串固定长度的字符连接起来的字符序列，Go的字符串是由单个UTF-8表示的字节连接起来的，由于该编码的不定性，字符串可能根据需要占用1~4byte；即字符串是字节的定长数组 字符串为不可变类型，故不能直接修改字符串的内容，如需修改，则需要将字符串内容复制到一个可写的变量中（一般是[]byte或[]rune），然后进行修改 字符串的转义 双引号创建可解析的字符串，支持转义，但不能用来引">
<meta property="og:type" content="article">
<meta property="og:title" content="go笔记">
<meta property="og:url" content="https://danyfd.github.io/2023/10/13/go%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="dany&#39;s blog">
<meta property="og:description" content="知识点字符串由一串固定长度的字符连接起来的字符序列，Go的字符串是由单个UTF-8表示的字节连接起来的，由于该编码的不定性，字符串可能根据需要占用1~4byte；即字符串是字节的定长数组 字符串为不可变类型，故不能直接修改字符串的内容，如需修改，则需要将字符串内容复制到一个可写的变量中（一般是[]byte或[]rune），然后进行修改 字符串的转义 双引号创建可解析的字符串，支持转义，但不能用来引">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://danyfd.github.io/img/avatar.png">
<meta property="article:published_time" content="2023-10-13T10:55:49.000Z">
<meta property="article:modified_time" content="2023-10-13T08:37:42.599Z">
<meta property="article:author" content="dany">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://danyfd.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://danyfd.github.io/2023/10/13/go%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'go笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-13 16:37:42'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-shijianxian"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/index.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="dany's blog"><span class="site-name">dany's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-shijianxian"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">go笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-13T10:55:49.000Z" title="发表于 2023-10-13 18:55:49">2023-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-13T08:37:42.599Z" title="更新于 2023-10-13 16:37:42">2023-10-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>65分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="go笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>由一串固定长度的字符连接起来的字符序列，Go的字符串是由单个UTF-8表示的字节连接起来的，由于该编码的不定性，字符串可能根据需要占用1~4byte；即字符串是字节的定长数组</p>
<p>字符串为不可变类型，故不能直接修改字符串的内容，如需修改，则需要将字符串内容复制到一个可写的变量中（一般是<code>[]byte</code>或<code>[]rune</code>），然后进行修改</p>
<h4 id="字符串的转义"><a href="#字符串的转义" class="headerlink" title="字符串的转义"></a>字符串的转义</h4><ul>
<li>双引号创建可解析的字符串，支持转义，但不能用来引用多行</li>
<li>反引号创建原生的字符串字面量，可由多行组成，不支持转义，且可包含除反引号外的所有字符</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">&quot;\&quot;Go web\&quot;,I love you \n&quot;</span></span><br><span class="line">str2 := <span class="string">`&quot;Go web&quot;,</span></span><br><span class="line"><span class="string">I love you \n`</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Go web&quot;</span>,I love you</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Go web&quot;</span>,</span><br><span class="line">I love you \n</span><br></pre></td></tr></table></figure>

<h4 id="字符串的修改"><a href="#字符串的修改" class="headerlink" title="字符串的修改"></a>字符串的修改</h4><ul>
<li><p>修改字节（用[]byte）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hi 世界!&quot;</span></span><br><span class="line">by := []<span class="type">byte</span>(str)</span><br><span class="line">by[<span class="number">2</span>] = <span class="string">&#x27;,&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Hi,世界</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改字符（用[]rune）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hi 世界&quot;</span></span><br><span class="line">by := []<span class="type">rune</span>(str)</span><br><span class="line">by[<span class="number">3</span>] = <span class="string">&#x27;中&#x27;</span></span><br><span class="line">by[<span class="number">4</span>] = <span class="string">&#x27;国&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Hi 中国</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Go 里面有三种类型的函数，函数参数、返回值以及它们的类型被统称为函数签名：  </p>
<ul>
<li>普通的带有名字的函数</li>
<li>匿名函数或者lambda函数</li>
<li>方法（Methods）</li>
</ul>
<p>这样是不正确的 Go 代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它必须是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数重载 (function overloading) 指的是可以编写多个同名函数，只要它们拥有不同的形参&#x2F;或者不同的返回值，在 Go 里面函数重载是不被允许的</p>
<p>函数值之间可以比较：若引用的是相同函数或都是 <code>nil</code> ，则认为是相同的函数</p>
<h3 id="函数的参数和返回值"><a href="#函数的参数和返回值" class="headerlink" title="函数的参数和返回值"></a>函数的参数和返回值</h3><p>任何一个有返回值（单个或多个）的函数都必须以 <code>return</code> 或 <code>panic</code>结尾</p>
<p>在函数调用时，切片 (slice)、字典 (map)、接口 (interface)、通道 (channel) 这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）</p>
<h4 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h4><p>命名返回值作为结果形参被初始化为相应类型的零值，当需要返回的时候，我们只需要一条简单的不带参数的 <code>return</code> 语句，即使只有一个命名返回值也需用括号括起来；当有多个非命名返回值时需用括号括起来，如<code>(int,int)</code>，任何一个非命名返回值在<code>return</code>中都要指出返回值变量或是一个可计算的值</p>
<h4 id="传递变长参数"><a href="#传递变长参数" class="headerlink" title="传递变长参数"></a>传递变长参数</h4><p>若变长参数的类型并不都相同时的传递方法：</p>
<ol>
<li><p>定义一个结构类型，假设它叫 <code>Options</code>，用以存储所有可能的参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">	par1 type1,</span><br><span class="line">	par2 type2,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 <code>F1()</code> 可以使用正常的参数 <code>a</code> 和 <code>b</code>，以及一个没有任何初始化的 <code>Options</code> 结构： <code>F1(a, b, Options &#123;&#125;)</code>。如果需要对选项进行初始化，则可以使用 <code>F1(a, b, Options &#123;par1:val1, par2:val2&#125;)</code></p>
</li>
<li><p>使用空接口：</p>
<p>若一个变长参数的类型没有被指定，则可以使用默认的空接口<code>interface&#123;&#125;</code>，该方案不仅可以用于长度未知的参数，还可以用于任何不确定类型的参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck</span><span class="params">(..,..,values … <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">		<span class="keyword">switch</span> v := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="type">int</span>: …</span><br><span class="line">			<span class="keyword">case</span> float: …</span><br><span class="line">			<span class="keyword">case</span> <span class="type">string</span>: …</span><br><span class="line">			<span class="keyword">case</span> <span class="type">bool</span>: …</span><br><span class="line">			<span class="keyword">default</span>: …</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="defer和追踪"><a href="#defer和追踪" class="headerlink" title="defer和追踪"></a>defer和追踪</h3><p>关键字 <code>defer</code> 允许我们推迟到函数返回之前（或任意位置执行 <code>return</code> 语句之后）一刻才执行某个语句或函数</p>
<p>当有多个 <code>defer</code> 行为被注册时，它们会以逆序执行（类似栈，即后进先出）</p>
<p>关键字 <code>defer</code> 允许我们进行一些函数执行完成后的收尾工作</p>
<h4 id="使用defer实现代码追踪"><a href="#使用defer实现代码追踪" class="headerlink" title="使用defer实现代码追踪"></a>使用<code>defer</code>实现代码追踪</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;entering:&quot;</span>, s)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;leaving:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> un(trace(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;in a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> un(trace(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;in b&quot;</span>)</span><br><span class="line">	a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">entering: b</span><br><span class="line">in b</span><br><span class="line">entering: a</span><br><span class="line">in a</span><br><span class="line">leaving: a</span><br><span class="line">leaving: b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用-defer-语句记录函数的参数与返回值"><a href="#使用-defer-语句记录函数的参数与返回值" class="headerlink" title="使用 defer 语句记录函数的参数与返回值"></a>使用 <code>defer</code> 语句记录函数的参数与返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">(s <span class="type">string</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;func1(%q) = %d, %v&quot;</span>, s, n, err)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">7</span>, io.EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	func1(<span class="string">&quot;Go&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output: 2011/10/04 10:46:11 func1(&quot;Go&quot;) = 7, EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>close()</code></td>
<td>用于管道通信</td>
</tr>
<tr>
<td><code>len()</code>、<code>cap()</code></td>
<td><code>len()</code> 用于返回某类型的长度或数量（字符串、数组、切片、<code>map</code> 和管道）；<code>cap()</code> 用于返回某个类型的最大容量（只能用于数组、切片和管道，不能用于 <code>map</code>）</td>
</tr>
<tr>
<td><code>new()</code>、<code>make()</code></td>
<td>分配内存，<code>new()</code> 值类型和自定义类型，<code>make</code> 内置引用类型（切片、<code>map</code> 和管道）</td>
</tr>
<tr>
<td><code>copy()</code>、<code>append()</code></td>
<td>用于复制和连接切片</td>
</tr>
<tr>
<td><code>panic()</code>、<code>recover()</code></td>
<td>均用于错误处理机制</td>
</tr>
<tr>
<td><code>print()</code>、<code>println()</code></td>
<td>底层打印函数，在部署环境中建议使用<code>fmt</code>包</td>
</tr>
<tr>
<td><code>complex()</code>、<code>real ()</code>、<code>imag()</code></td>
<td>用于创建和操作复数</td>
</tr>
</tbody></table>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>可以将匿名函数赋值给变量，即保存函数的地址到变量中，然后通过变量名对函数进行调用，也可以直接对匿名函数进行调用，匿名函数也被称为闭包：</p>
<p><code>func(x, y int) int &#123; return x + y &#125; (3, 4)</code></p>
<h4 id="应用闭包：将参数作为返回值"><a href="#应用闭包：将参数作为返回值" class="headerlink" title="应用闭包：将参数作为返回值"></a>应用闭包：将参数作为返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f = Adder()</span><br><span class="line">    fmt.Print(f(<span class="number">1</span>),<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    fmt.Print(f(<span class="number">20</span>),<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    fmt.Print(f(<span class="number">300</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(delta <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        x += delta</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="comment">//1 - 21 - 321</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量</p>
<h5 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h5><p>一个返回值为另一个函数的函数；在创建一系列相似函数时非常有用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeAddSuffix</span><span class="params">(suffix <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !strings.HasSuffix(name, suffix) &#123;</span><br><span class="line">			<span class="keyword">return</span> name + suffix</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addBmp := MakeAddSuffix(<span class="string">&quot;.bmp&quot;</span>)</span><br><span class="line">addJpeg := MakeAddSuffix(<span class="string">&quot;.jpeg&quot;</span>)</span><br><span class="line">addBmp(<span class="string">&quot;file&quot;</span>) <span class="comment">// returns: file.bmp</span></span><br><span class="line">addJpeg(<span class="string">&quot;file&quot;</span>) <span class="comment">// returns: file.jpeg</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用闭包调试"><a href="#使用闭包调试" class="headerlink" title="使用闭包调试"></a>使用闭包调试</h4><p>在分析和调试复杂的程序时，无数个函数在不同的代码文件中相互调用，如果这时候能够准确地知道哪个文件中的具体哪个函数正在执行，对于调试是十分有帮助的；包 <code>runtime</code> 中的函数 <code>Caller()</code> 提供了相应的信息，因此可以在需要的时候实现一个 <code>where()</code> 闭包函数来打印函数执行的位置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">where := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _,file,line,_ := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">    log.Printf(<span class="string">&quot;%s:%d&quot;</span>,file,line)</span><br><span class="line">&#125;</span><br><span class="line">where()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="通过内存缓存提升性能"><a href="#通过内存缓存提升性能" class="headerlink" title="通过内存缓存提升性能"></a>通过内存缓存提升性能</h4><p>在大量计算时，提升性能最直接有效的方式即避免重复计算，在缓存重复利用相同计算的结果称为内存缓存</p>
<p>如斐波那契数列，要计算数列中第 n 个数字，需要先得到之前两个数的值，但很明显绝大多数情况下前两个数的值都是已经计算过的，此时将第 n 个数的值存在数组中索引为 n 的位置</p>
<h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是具有相同 <strong>唯一类型</strong> 的一组已编号且长度固定的数据项序列，声明格式为：</p>
<p><code>var arr1 [5]int</code></p>
<p>数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定</p>
<p>go数组是值类型，可通过<code>new()</code>创建：<code>var arr1 = new([5]int)</code>，故在函数中作为参数传入时不修改原始数组，若想修改，则需使用<code>&amp;</code>操作符以引用方式传入</p>
<p>该种方式和 <code>var arr2 [5]int</code> 的区别是：<code>arr1</code> 的类型是 <code>*[5]int</code>，而 <code>arr2</code> 的类型是 <code>[5]int</code>；这样的结果就是当把一个数组赋值给另一个时，需要再做一次数组内存的拷贝操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr2 := *arr1</span><br><span class="line">arr2[<span class="number">2</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">//这样两个数组就有了不同的值，在赋值后修改 arr2 不会对 arr1 生效</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>切片提供了计算容量的函数 <code>cap()</code> 可以测量切片最长可以达到多少：切片的长度 + 数组除切片之外的长度。若<code>s</code> 是一个切片，<code>cap(s)</code> 就是从 <code>s[0]</code> 到数组末尾的数组长度：<code>0 &lt;= len(s) &lt;= cap(s)</code></p>
<p>slice由三个部分构成：指针、长度和容量</p>
<p>slice不能直接用<code>==</code>进行比较，对于字节型slice可以使用<code>bytes.Equal</code>函数判断是否相等，对于其它类型需要展开每个元素比较（slice允许与nil比较）</p>
<p>一个nil值的slice的行为和其它任意0长度的slice一样；若需要判断一个slice是否为空，需要使用len(s) &#x3D;&#x3D; 0 判断，不应该使用s &#x3D;&#x3D; nil</p>
<p>可以将 <code>s2</code> 向后移动一位 <code>s2 = s2[1:]</code>，但是<code>s2 = s2[-1:]</code> 会导致编译错误，切片不能被重新分片获取数组的前一个元素</p>
<h5 id="创建切片"><a href="#创建切片" class="headerlink" title="创建切片"></a>创建切片</h5><p>当相关数组未定义时，可以用 <code>make()</code> 创建切片，同时创建好相关数组：<code>var slice1 []type = make([]type, len)</code>；可以简写为<code>slice1 := make([]type,len)</code>，<code>len</code>是数组的长度且是<code>slice</code>的初始长度</p>
<p>故定义<code>s2 := make([]int,10)</code>，则<code>cap(s2)==len(s2)==10</code></p>
<p>若想创建一个 <code>slice1</code>不占用整个数组，只占用以 <code>len</code> 为个数个项，那么只要：<code>slice1 := make([]type, len, cap)</code></p>
<p><code>make()</code> 的使用方式是：<code>func make([]T, len, cap)</code>，其中 <code>cap</code> 是可选参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">new</span>([<span class="number">100</span>]<span class="type">int</span>)[<span class="number">0</span>:<span class="number">50</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="切片的扩容"><a href="#切片的扩容" class="headerlink" title="切片的扩容"></a>切片的扩容</h5><h6 id="扩容函数"><a href="#扩容函数" class="headerlink" title="扩容函数"></a>扩容函数</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type,old slice,<span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                newcap += newcap/<span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                newcap = <span class="built_in">cap</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="扩容原理"><a href="#扩容原理" class="headerlink" title="扩容原理"></a>扩容原理</h6><ul>
<li>当前所需容量（cap）大于原容量两倍（doublecap），则最终申请容量（newcap）为当前所需容量（cap）</li>
<li>若不大于原容量两倍时<ol>
<li>原切片长度小于1024则申请原容量的两倍</li>
<li>否则，最终申请容量（newcap，初始值等于 old.cap）每次增加newcap&#x2F;4，直到大于所需容量（cap）为止，然后判断最终容量是否溢出，若溢出，最终申请容量等于所需容量</li>
</ol>
</li>
</ul>
<h6 id="go切片扩容为什么是2倍"><a href="#go切片扩容为什么是2倍" class="headerlink" title="go切片扩容为什么是2倍"></a>go切片扩容为什么是2倍</h6><ol>
<li><p>确定切片的大致容量</p>
</li>
<li><p>根据元素所占字节大小，最终确定容量</p>
<p>当元素所占字节大小为1、8或2的倍数时，会执行内存对齐操作</p>
</li>
</ol>
<h5 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h5><p> Go 的多维切片可以任意切分，而且，内层的切片必须单独分配</p>
<h5 id="bytes包"><a href="#bytes包" class="headerlink" title="bytes包"></a>bytes包</h5><p><code>bytes</code> 包和字符串包十分类似，而且还包含一个十分有用的类型 <code>Buffer</code></p>
<p>长度可变的 <code>bytes</code> 的 buffer，提供 <code>Read()</code> 和 <code>Write()</code> 方法，读写长度未知的 <code>bytes</code> 最好使用 <code>buffer</code></p>
<h6 id="buffer定义"><a href="#buffer定义" class="headerlink" title="buffer定义"></a>buffer定义</h6><ul>
<li><code>var buffer bytes.Buffer</code></li>
<li><code>var r *bytes.Buffer = new(bytes.Buffer)</code></li>
<li><code>func NewBuffer(buf []byte) *Buffer</code>；<code>NewBuffer</code> 最好用在从 <code>buf</code> 读取的时候</li>
</ul>
<h6 id="通过buffer串联字符串"><a href="#通过buffer串联字符串" class="headerlink" title="通过buffer串联字符串"></a>通过buffer串联字符串</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s,ok := getNextString();ok&#123;</span><br><span class="line">        buffer.WriteString(s)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(buffer.String(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方式比使用<code>+=</code>更节省内存和CPU，尤其是串联的字符串数目较多时</p>
<h4 id="new-和make-的区别"><a href="#new-和make-的区别" class="headerlink" title="new()和make()的区别"></a>new()和make()的区别</h4><p>两者都在堆上分配内存，但它们的行为不同，适用于不同类型</p>
<ul>
<li><code>new(T)</code> 为每个新类型 <code>T</code> 分配一片内存，初始化为 <code>0</code> 并且返回类型为 <code>*T</code> 的内存地址：这种方法 <strong>返回一个指向类型为 <code>T</code>，值为 <code>0</code> 的地址的指针</strong>，它适用于值类型如数组和结构体，相当于 <code>&amp;T&#123;&#125;</code></li>
<li><code>make(T)</code> <strong>返回一个类型为 T 的初始值</strong>，它只适用于 3 种内建的引用类型：切片、<code>map</code> 和 <code>channel</code></li>
</ul>
<p>即<code>new()</code>分配内存，<code>make()</code>初始化，如下图所示：</p>
<img src="https://s1.ax1x.com/2023/03/09/ppm4rY6.png" style="zoom:50%"/>

<h4 id="for-range结构"><a href="#for-range结构" class="headerlink" title="for-range结构"></a>for-range结构</h4><p>可以应用于数组和切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ix, value := <span class="keyword">range</span> slice1 &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个返回值 <code>ix</code> 是数组或者切片的索引，第二个是在该索引位置的值</p>
<p><code>value</code> 只是 <code>slice1</code> 某个索引位置的值的一个拷贝，不能用来修改 <code>slice1</code> 该索引位置的值</p>
<h4 id="切片重组"><a href="#切片重组" class="headerlink" title="切片重组"></a>切片重组</h4><p>在切片达到容量上限后扩容改变切片长度的过程</p>
<h4 id="切片的复制与追加"><a href="#切片的复制与追加" class="headerlink" title="切片的复制与追加"></a>切片的复制与追加</h4><p>如果想增加切片的容量，必须创建一个更大的切片并把原分片的内容都拷贝过来</p>
<p>可以使用<code>copy()</code>和<code>append()</code>函数，追加的元素必须和原切片元素是同类型</p>
<h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><p>如果 <code>s</code> 的容量不足以存储新增元素，<code>append()</code> 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组，<code>append()</code> 方法总是返回成功，除非系统内存耗尽</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AppendByte</span><span class="params">(slice []<span class="type">byte</span>, data ...<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(slice)</span><br><span class="line">    n := m + <span class="built_in">len</span>(data)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="built_in">cap</span>(slice) &#123;</span><br><span class="line">        newSlice := <span class="built_in">make</span>([]<span class="type">byte</span>,(n+<span class="number">1</span>)*<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">copy</span>(newSlice,slice)</span><br><span class="line">        slice = newSlice</span><br><span class="line">    &#125;</span><br><span class="line">    slice = slice[<span class="number">0</span>:n]</span><br><span class="line">    <span class="built_in">copy</span>(slice[m:n],data)</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="append常见操作"><a href="#append常见操作" class="headerlink" title="append常见操作"></a>append常见操作</h6><ol>
<li><p>将切片 <code>b</code> 的元素追加到切片 <code>a</code> 之后：<code>a = append(a, b...)</code></p>
</li>
<li><p>复制切片 <code>a</code> 的元素到新的切片 <code>b</code> 上：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">make</span>([]T, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">copy</span>(b, a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除位于索引 <code>i</code> 的元素：<code>a = append(a[:i], a[i+1:]...)</code></p>
</li>
<li><p>切除切片 <code>a</code> 中从索引 <code>i</code> 至 <code>j</code> 位置的元素：<code>a = append(a[:i], a[j:]...)</code></p>
</li>
<li><p>为切片 <code>a</code> 扩展 <code>j</code> 个元素长度：<code>a = append(a, make([]T, j)...)</code></p>
</li>
<li><p>在索引 <code>i</code> 的位置插入元素 <code>x</code>：<code>a = append(a[:i], append([]T&#123;x&#125;, a[i:]...)...)</code></p>
</li>
<li><p>在索引 <code>i</code> 的位置插入长度为 <code>j</code> 的新切片：<code>a = append(a[:i], append(make([]T, j), a[i:]...)...)</code></p>
</li>
<li><p>在索引 <code>i</code> 的位置插入切片 <code>b</code> 的所有元素：<code>a = append(a[:i], append(b, a[i:]...)...)</code></p>
</li>
<li><p>取出位于切片 <code>a</code> 最末尾的元素 <code>x</code>：<code>x, a = a[len(a)-1], a[:len(a)-1]</code></p>
</li>
<li><p>将元素 <code>x</code> 追加到切片 <code>a</code>：<code>a = append(a, x)</code></p>
</li>
</ol>
<h5 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h5><p><code>func copy(dst, src []T) int</code> 方法将类型为 <code>T</code> 的切片从源地址 <code>src</code> 拷贝到目标地址 <code>dst</code>，覆盖 <code>dst</code> 的相关元素，并且返回拷贝的元素个数。源地址和目标地址可能会有重叠。拷贝个数是 <code>src</code> 和 <code>dst</code> 的长度最小值。若 <code>src</code> 是字符串则元素类型就是 <code>byte</code>。若还想继续使用 <code>src</code>，在拷贝结束后执行 <code>src = dst</code></p>
<h4 id="字符串生成字节切片"><a href="#字符串生成字节切片" class="headerlink" title="字符串生成字节切片"></a>字符串生成字节切片</h4><p>可以通过<code>c := []byte(s)</code>获取一个字节的切片<code>c</code>，还可以通过 <code>copy()</code> 函数来达到相同的目的：<code>copy(dst []byte, src string)</code></p>
<p>将一个字符串追加到某一个字节切片的尾部：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b []<span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">b = <span class="built_in">append</span>(b, s...)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="字符串和切片的内存结构"><a href="#字符串和切片的内存结构" class="headerlink" title="字符串和切片的内存结构"></a>字符串和切片的内存结构</h4><p>在内存中，一个字符串实际上是一个双字结构，即一个指向实际数据的指针和记录字符串长度的整数。因为指针对用户来说是完全不可见，因此我们可以依旧把字符串看做是一个值类型，也就是一个字符数组</p>
<p>字符串 <code>string s = &quot;hello&quot;</code> 和子字符串 <code>t = s[2:3]</code> 在内存中的结构可以用下图表示：</p>
<img src="https://s1.ax1x.com/2023/03/09/ppmHohn.png" style="zoom:50%"/>

<h4 id="修改字符串的某个字符"><a href="#修改字符串的某个字符" class="headerlink" title="修改字符串的某个字符"></a>修改字符串的某个字符</h4><p>Go 中字符串不可变，即 <code>str[index]</code> 这样的表达式是不可以被放在等号左侧的</p>
<p>因此必须先将字符串转换成字节数组，然后再通过修改数组中的元素值来达到修改字符串的目的，最后将字节数组转换回字符串格式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">c := []<span class="type">byte</span>(s)</span><br><span class="line">c[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">s2 := <span class="type">string</span>(c)	<span class="comment">//s2 == &quot;cello&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="字节数组对比函数"><a href="#字节数组对比函数" class="headerlink" title="字节数组对比函数"></a>字节数组对比函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a, b[]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(a) &amp;&amp; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> a[i] &gt; b[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> a[i] &lt; b[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组的长度可能不同</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">len</span>(a) &lt; <span class="built_in">len</span>(b):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">len</span>(a) &gt; <span class="built_in">len</span>(b):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// 数组相等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="搜索及排序切片和数组"><a href="#搜索及排序切片和数组" class="headerlink" title="搜索及排序切片和数组"></a>搜索及排序切片和数组</h4><p>标准库提供了 <code>sort</code> 包实现常见的搜索和排序操作。可以使用 <code>sort</code> 包中的函数 <code>func Ints(a []int)</code> 实现对 <code>int</code> 类型的切片排序。例如 <code>sort.Ints(arri)</code>，其中变量 <code>arri</code> 就是需要被升序排序的数组或切片。为了检查某个数组是否已经被排序，可通过函数 <code>IntsAreSorted(a []int) bool</code> 检查，若返回 <code>true</code> 则表示已经被排序</p>
<p>类似的，可以使用函数 <code>func Float64s(a []float64)</code> 来排序 <code>float64</code> 的元素，或使用函数 <code>func Strings(a []string)</code> 排序字符串元素</p>
<p>想要在数组或切片中搜索一个元素，该数组或切片必须先被排序（因为标准库的搜索算法使用的是二分法）。使用函数 <code>func SearchInts(a []int, n int) int</code> 进行搜索，并返回对应结果的索引值</p>
<p>当然，还可以搜索 <code>float64</code> 和字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchFloat64s</span><span class="params">(a []<span class="type">float64</span>, x <span class="type">float64</span>)</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchStrings</span><span class="params">(a []<span class="type">string</span>, x <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="切片和垃圾回收"><a href="#切片和垃圾回收" class="headerlink" title="切片和垃圾回收"></a>切片和垃圾回收</h4><p>只有在没有任何切片指向的时候，底层的数组内存才会被释放，这种特性有时会导致程序占用多余的内存</p>
<p><strong>示例</strong> 函数 <code>FindDigits()</code> 将一个文件加载到内存，然后搜索其中所有的数字并返回一个切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> digitRegexp = regexp.MustCompile(<span class="string">&quot;[0-9]+&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">return</span> digitRegexp.Find(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码可以顺利运行，但返回的 <code>[]byte</code> 指向的底层是整个文件的数据。只要该返回的切片不被释放，垃圾回收器就不能释放整个文件所占用的内存。换句话说，一点点有用的数据却占用了整个文件的内存。</p>
<p>想要避免这个问题，可以通过拷贝我们需要的部分到一个新的切片中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   b, _ := ioutil.ReadFile(filename)</span><br><span class="line">   b = digitRegexp.Find(b)</span><br><span class="line">   c := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(b))</span><br><span class="line">   <span class="built_in">copy</span>(c, b)</span><br><span class="line">   <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>事实上，上面这段代码只能找到第一个匹配正则表达式的数字串。要想找到所有的数字，可以尝试下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindFileDigits</span><span class="params">(filename <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   fileBytes, _ := ioutil.ReadFile(filename)</span><br><span class="line">   b := digitRegexp.FindAll(fileBytes, <span class="built_in">len</span>(fileBytes))</span><br><span class="line">   c := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">for</span> _, bytes := <span class="keyword">range</span> b &#123;</span><br><span class="line">      c = <span class="built_in">append</span>(c, bytes...)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="键值对元素"><a href="#键值对元素" class="headerlink" title="键值对元素"></a>键值对元素</h3><p><code>val1,isPresent = map1[key1]</code></p>
<p><code>isPresent</code>返回一个<code>bool</code>值：若 <code>key1</code> 存在于 <code>map1</code>，<code>val1</code> 就是 <code>key1</code> 对应的 <code>value</code> 值，并且 <code>isPresent</code> 为 <code>true</code>；若<code>key1</code> 不存在，<code>val1</code> 就是一个空值，且 <code>isPresent</code> 返回 <code>false</code></p>
<p>判断某个<code>key</code>是否存在的常规方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := map1[key1]; ok &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>map1</code>中删除<code>key1</code>：<code>delete(map1,key1)</code>；若<code>key1</code>不存在，该操作不会产生错误</p>
<p> <code>map</code> 不是按照 key 的顺序排列的，也不是按照 value 的序排列的</p>
<blockquote>
<p>map 的本质是散列表，而 map 的增长扩容会导致重新进行散列，这就可能使 map 的遍历结果在扩容前后变得不可靠，Go 设计者为了让大家不依赖遍历的顺序，每次遍历的起点–即起始 bucket 的位置不一样，即不让遍历都从某个固定的 bucket0 开始，所以即使未扩容时我们遍历出来的 map 也总是无序的</p>
</blockquote>
<h3 id="map类型的切片"><a href="#map类型的切片" class="headerlink" title="map类型的切片"></a>map类型的切片</h3><p>获取一个 <code>map</code> 类型的切片，必须使用两次 <code>make()</code> 函数，第一次分配切片，第二次分配切片中每个 <code>map</code> 元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Version A:</span></span><br><span class="line">    items := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> items &#123;</span><br><span class="line">        items[i] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">		items[i][<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Version A: Value of items: %v\n&quot;</span>, items)</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// Version B: NOT GOOD!</span></span><br><span class="line">	items2 := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items2 &#123;</span><br><span class="line">		item = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">1</span>) <span class="comment">// item is only a copy of the slice element.</span></span><br><span class="line">		item[<span class="number">1</span>] = <span class="number">2</span> <span class="comment">// This &#x27;item&#x27; will be lost on the next iteration.</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Version B: Value of items: %v\n&quot;</span>, items2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Version A: Value of items: [map[1:2] map[1:2] map[1:2] map[1:2] map[1:2]]</span><br><span class="line">Version B: Value of items: [map[] map[] map[] map[] map[]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> A 通过索引使用切片的 <code>map</code> 元素。 B 中获得的项只是 <code>map</code> 值的一个拷贝，所以真正的 <code>map</code> 元素没有得到初始化</p>
<h3 id="将map的键值对调"><a href="#将map的键值对调" class="headerlink" title="将map的键值对调"></a>将map的键值对调</h3><p>若<code>map</code>的值类型可以作为key且所有value是唯一的，则可以通过下面的方法对调：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	barVal = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;alpha&quot;</span>: <span class="number">34</span>, <span class="string">&quot;bravo&quot;</span>: <span class="number">56</span>, <span class="string">&quot;charlie&quot;</span>: <span class="number">23</span>,</span><br><span class="line">							<span class="string">&quot;delta&quot;</span>: <span class="number">87</span>, <span class="string">&quot;echo&quot;</span>: <span class="number">56</span>, <span class="string">&quot;foxtrot&quot;</span>: <span class="number">12</span>,</span><br><span class="line">							<span class="string">&quot;golf&quot;</span>: <span class="number">34</span>, <span class="string">&quot;hotel&quot;</span>: <span class="number">16</span>, <span class="string">&quot;indio&quot;</span>: <span class="number">87</span>,</span><br><span class="line">							<span class="string">&quot;juliet&quot;</span>: <span class="number">65</span>, <span class="string">&quot;kili&quot;</span>: <span class="number">43</span>, <span class="string">&quot;lima&quot;</span>: <span class="number">98</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	invMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>, <span class="built_in">len</span>(barVal))</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> barVal &#123;</span><br><span class="line">		invMap[v] = k</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;inverted:&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> invMap &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Key: %v, Value: %v / &quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结构体和方法"><a href="#结构体和方法" class="headerlink" title="结构体和方法"></a>结构体和方法</h2><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>将创建对象的具体过程屏蔽隔离；由工厂创建不同种类的对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    fd      <span class="type">int</span>     <span class="comment">// 文件描述符</span></span><br><span class="line">    name    <span class="type">string</span>  <span class="comment">// 文件名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="type">int</span>, name <span class="type">string</span>)</span></span> *File &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;File&#123;fd, name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := NewFile(<span class="number">10</span>, <span class="string">&quot;./test.txt&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若 <code>File</code> 是一个结构体类型，则 <code>new(File)</code> 和 <code>&amp;File&#123;&#125;</code> 是等价的</p>
<h4 id="强制使用工厂方法"><a href="#强制使用工厂方法" class="headerlink" title="强制使用工厂方法"></a>强制使用工厂方法</h4><h5 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h5><p>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，则这种形式的标识符的对象就可以被外部包的代码所使用（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是它们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）</p>
<p>当使用 <code>.</code> 作为包的别名时，可以不通过包名来使用其中的项目：<code>import . &quot;./pack1&quot;</code></p>
<p><code>import _ &quot;./pack1/pack1&quot;</code></p>
<p><code>pack1</code> 包只导入其副作用，也就是说，只执行它的 <code>init()</code> 函数并初始化其中的全局变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> matrix <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMatrix</span><span class="params">(params)</span></span> *matrix &#123;</span><br><span class="line">    m := <span class="built_in">new</span>(matrix) <span class="comment">// 初始化 m</span></span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在其他包中使用工厂方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;matrix&quot;</span></span><br><span class="line">...</span><br><span class="line">wrong := <span class="built_in">new</span>(matrix.matrix)     <span class="comment">// 编译失败（matrix 是私有的）</span></span><br><span class="line">right := matrix.NewMatrix(...)  <span class="comment">// 实例化 matrix 的唯一方式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="内嵌结构体和匿名字段"><a href="#内嵌结构体和匿名字段" class="headerlink" title="内嵌结构体和匿名字段"></a>内嵌结构体和匿名字段</h3><p>结构体可以包含一个或多个 匿名（或内嵌）字段，只有字段的类型是必须的，此时类型就是字段的名字，因此每种数据类型只能有一个匿名字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> innerS <span class="keyword">struct</span> &#123;</span><br><span class="line">	in1 <span class="type">int</span></span><br><span class="line">	in2 <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> outerS <span class="keyword">struct</span> &#123;</span><br><span class="line">	b    <span class="type">int</span></span><br><span class="line">	c    <span class="type">float32</span></span><br><span class="line">	<span class="type">int</span>  <span class="comment">// anonymous field</span></span><br><span class="line">	innerS <span class="comment">//anonymous field</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	outer := <span class="built_in">new</span>(outerS)</span><br><span class="line">	outer.b = <span class="number">6</span></span><br><span class="line">	outer.c = <span class="number">7.5</span></span><br><span class="line">	outer.<span class="type">int</span> = <span class="number">60</span></span><br><span class="line">	outer.in1 = <span class="number">5</span></span><br><span class="line">	outer.in2 = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;outer.b is: %d\n&quot;</span>, outer.b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;outer.c is: %f\n&quot;</span>, outer.c)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;outer.int is: %d\n&quot;</span>, outer.<span class="type">int</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;outer.in1 is: %d\n&quot;</span>, outer.in1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;outer.in2 is: %d\n&quot;</span>, outer.in2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用结构体字面量</span></span><br><span class="line">	outer2 := outerS&#123;<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">60</span>, innerS&#123;<span class="number">5</span>, <span class="number">10</span>&#125;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;outer2 is:&quot;</span>, outer2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h4><p>当两个字段拥有相同的名字（可能是继承来的名字）时：</p>
<ol>
<li>外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式</li>
<li>如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;a <span class="type">int</span>&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;a, b <span class="type">int</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;A; B&#125;</span><br><span class="line"><span class="keyword">var</span> c C</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> D <span class="keyword">struct</span> &#123;B; b <span class="type">float32</span>&#125;</span><br><span class="line"><span class="keyword">var</span> d D</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时使用<code>c.a</code>是错误的；使用<code>d.b</code>没有问题</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>类型无需显示声明实现了某个接口，接口可以被隐式地实现，多个类型可以实现同一接口</li>
<li>实现某个接口的类型（除了实现接口方法外）可以有其他的方法</li>
<li>一个类型可以实现多个接口</li>
<li>接口类型可以包含一个实例的引用，该实例类型实现了此接口（接口是动态类型）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">	Area() <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">	side <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span></span> Area() <span class="type">float32</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sq1 := <span class="built_in">new</span>(Square)</span><br><span class="line">	sq1.side = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> areaIntf Shaper</span><br><span class="line">	areaIntf = sq1</span><br><span class="line">	<span class="comment">// shorter,without separate declaration:</span></span><br><span class="line">	<span class="comment">// areaIntf := Shaper(sq1)</span></span><br><span class="line">	<span class="comment">// or even:</span></span><br><span class="line">	<span class="comment">// areaIntf := sq1</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;The square has area: %f\n&quot;</span>, areaIntf.Area())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//The square has area: 25.000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述实例中创建了一个<code>Square</code>的实例，且在主程序外定义了一个接受者类型是<code>Square</code>的<code>Area()</code>：结构体<code>Square</code>实现了接口<code>Shaper</code> </p>
<p>故可将一个 <code>Square</code> 类型的变量赋值给一个接口类型的变量：<code>areaIntf = sq1</code> </p>
<p>现在接口变量包含一个指向 <code>Square</code> 变量的引用，通过它可以调用 <code>Square</code> 上的方法 <code>Area()</code>；接口变量里包含了接收者实例的值和指向对应方法表的指针；<strong>这是多态的Go版本</strong></p>
<p>如果 <code>Shaper</code> 有另外一个方法 <code>Perimeter()</code>，但是 <code>Square</code> 没有实现它，即使没有在 <code>Square</code> 实例上调用这个方法，编译器会给出错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cannot use sq1 (type *Square) as type Shaper in assignment:</span><br><span class="line">*Square does not implement Shaper (missing Area method)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口嵌套接口"><a href="#接口嵌套接口" class="headerlink" title="接口嵌套接口"></a>接口嵌套接口</h3><p>一个接口可以包含一个或多个其他的接口，相当于直接将这些内嵌接口的方法列举在外层接口中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="type">bool</span></span><br><span class="line">    Write(b Buffer) <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型；语法格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value,ok := x.(T)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）</p>
<p>该断言表达式会返回 x 的值（ value）和一个布尔值（ ok），可根据该布尔值判断 x 是否为 T 类型：</p>
<ul>
<li>若T是具体某个类型，则检查x的动态类型是否等于具体类型T；若成功，则返回x的动态值，类型为T</li>
<li>若T 是接口类型，检查 x 的动态类型是否满足 T；若成功，x 的动态值不被提取，返回一个类型为 T 的接口值</li>
<li>无论 T 是什么类型，如果 x 是 nil 接口值，类型断言都会失败</li>
</ul>
<p>通过类型断言可以做到：</p>
<ul>
<li>检查<code>i</code>是否为<code>nil</code></li>
<li>检查<code>i</code>存储的值是否为某个类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">10</span></span><br><span class="line">t1 := i.(<span class="type">int</span>)</span><br><span class="line">fmt.Println(t1)</span><br><span class="line">fmt.Println(<span class="string">&quot;====分隔线====&quot;</span>)</span><br><span class="line">t2 := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(t2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">=====分隔线=====</span><br><span class="line">panic: interface conversion: interface &#123;&#125; is int, not string</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">	E:/GoPlayer/src/main.go:12 +0x10e</span><br><span class="line">exit status 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">classifier</span><span class="params">(items ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, x := <span class="keyword">range</span> items &#123;</span><br><span class="line">		<span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Param #%d is a bool\n&quot;</span>, i)</span><br><span class="line">		<span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Param #%d is a float64\n&quot;</span>, i)</span><br><span class="line">		<span class="keyword">case</span> <span class="type">int</span>, <span class="type">int64</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Param #%d is a int\n&quot;</span>, i)</span><br><span class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Param #%d is a nil\n&quot;</span>, i)</span><br><span class="line">		<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Param #%d is a string\n&quot;</span>, i)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Param #%d is unknown\n&quot;</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口实例：使用Sorter接口排序"><a href="#接口实例：使用Sorter接口排序" class="headerlink" title="接口实例：使用Sorter接口排序"></a>接口实例：使用Sorter接口排序</h3><p><code>sort</code> 包要对一组数字或字符串排序，需要实现三个方法：反映元素个数的 <code>Len()</code> 方法、比较第 <code>i</code> 和 <code>j</code> 个元素的 <code>Less(i, j)</code> 方法以及交换第 <code>i</code> 和 <code>j</code> 个元素的 <code>Swap(i, j)</code> 方法</p>
<p>排序函数的算法只会使用到这三个方法（可以使用任何排序算法来实现，此处我们使用冒泡排序）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Sorter)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> pass := <span class="number">1</span>; pass &lt; data.Len(); pass++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; data.Len() - pass; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> data.Less(i+<span class="number">1</span>, i) &#123;</span><br><span class="line">                data.Swap(i, i + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Sort</code> 函数接收一个接口类型的参数：<code>Sorter</code> ，它声明了这些方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sorter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>int</code> 是待排序序列长度的类型，而不是说要排序的对象一定要是一组 <code>int</code>，现在若想对一个 <code>int</code> 数组排序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntArray []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntArray)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntArray)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntArray)</span></span> Swap(i, j <span class="type">int</span>)      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data := []<span class="type">int</span>&#123;<span class="number">74</span>, <span class="number">59</span>, <span class="number">238</span>, <span class="number">-784</span>, <span class="number">9845</span>, <span class="number">959</span>, <span class="number">905</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">42</span>, <span class="number">7586</span>, <span class="number">-5467984</span>, <span class="number">7586</span>&#125;</span><br><span class="line">a := sort.IntArray(data) <span class="comment">//conversion to type IntArray from package sort</span></span><br><span class="line">sort.Sort(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p><strong>空接口或者最小接口</strong> 不包含任何方法，它对实现不做任何要求：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以给一个空接口类型的变量 <code>var val interface &#123;&#125;</code> 赋任何类型的值</p>
<p>每个 <code>interface &#123;&#125;</code> 变量在内存中占据两个字长：一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针</p>
<h4 id="构建通用类型"><a href="#构建通用类型" class="headerlink" title="构建通用类型"></a>构建通用类型</h4><p>前面的排序实例中可以实现对<code>int</code>、<code>float</code>、<code>string</code>数组的排序，对于其他类型的排序可以使用空接口：<code>Element：type Element interface&#123;&#125;</code></p>
<p>然后定义一个容器类型结构体<code>Vector</code>，包含一个<code>Element</code>类型元素的切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vector <span class="keyword">struct</span> &#123;</span><br><span class="line">    a []Element</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Vector</code> 里能放任何类型的变量，因为任何类型都实现了空接口，实际上 <code>Vector</code> 里放的每个元素可以是不同类型的。我们为它定义一个 <code>At()</code> 方法用于返回第 <code>i</code> 个元素，再定一个 <code>Set()</code> 方法用于设置第 <code>i</code> 个元素的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Vector)</span></span> At(i <span class="type">int</span>) Element &#123;</span><br><span class="line">	<span class="keyword">return</span> p.a[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Vector)</span></span> Set(i <span class="type">int</span>, e Element) &#123;</span><br><span class="line">	p.a[i] = e</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Vector</code> 中存储的所有元素都是 <code>Element</code> 类型，要得到它们的原始类型（unboxing：拆箱）需要用到类型断言</p>
<h5 id="通用类型节点数据结构"><a href="#通用类型节点数据结构" class="headerlink" title="通用类型节点数据结构"></a>通用类型节点数据结构</h5><p>在列表和树等数据结构中定义时使用了节点的递归型结构体类型，现在可以使用空接口作为数据字段的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	le   *Node</span><br><span class="line">	data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	ri   *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNode</span><span class="params">(left, right *Node)</span></span> *Node &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Node&#123;left, <span class="literal">nil</span>, right&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> SetData(data <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	n.data = data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	root := NewNode(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">	root.SetData(<span class="string">&quot;root node&quot;</span>)</span><br><span class="line">	<span class="comment">// make child (leaf) nodes:</span></span><br><span class="line">	a := NewNode(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">	a.SetData(<span class="string">&quot;left node&quot;</span>)</span><br><span class="line">	b := NewNode(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">	b.SetData(<span class="string">&quot;right node&quot;</span>)</span><br><span class="line">	root.le = a</span><br><span class="line">	root.ri = b</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, root) <span class="comment">// Output: &amp;&#123;0x125275f0 root node 0x125275e0&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="复制数据切片至空接口切片"><a href="#复制数据切片至空接口切片" class="headerlink" title="复制数据切片至空接口切片"></a>复制数据切片至空接口切片</h4><p>若有一个 <code>myType</code> 类型的数据切片，将切片中的数据复制到一个空接口切片中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSlice []myType = FuncReturnSlice()</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = dataSlice</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>此时将会编译出错：</strong><code>cannot use dataSlice (type []myType) as type []interface &#123; &#125; in assignment</code></p>
<p>因为它们两个在内存中的布局不一样，必须用<code>for-range</code>一个一个显示赋值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSlice []myType = FuncReturnSlice()</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(dataSlice))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> dataSlice &#123;</span><br><span class="line">    interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="接口到接口"><a href="#接口到接口" class="headerlink" title="接口到接口"></a>接口到接口</h4><p>一个接口的值可以赋值给另一个接口变量，只要底层类型实现了必要的方法。这个转换是在运行时进行检查的，转换失败会导致一个运行时错误：这是 <code>Go</code> 语言动态的一面，可以拿它和 <code>Ruby</code> 和 <code>Python</code> 这些动态语言相比较</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ai AbsInterface		<span class="comment">// declares method Abs()</span></span><br><span class="line"><span class="keyword">type</span> SqrInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Sqr() float</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> si SqrInterface</span><br><span class="line">pp := <span class="built_in">new</span>(Point)		<span class="comment">// say *Point implements Abs, Sqr</span></span><br><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty = pp				<span class="comment">// everything satisfies empty</span></span><br><span class="line">ai = empty.(AbsInterface) <span class="comment">// underlying value pp implements Abs()</span></span><br><span class="line"><span class="comment">// (runtime failure otherwise)</span></span><br><span class="line">si = ai.(SqrInterface) 	<span class="comment">// *Point has Sqr() even though AbsInterface doesn’t</span></span><br><span class="line">empty = si				<span class="comment">// *Point implements empty set</span></span><br><span class="line"><span class="comment">// Note: statically checkable so type assertion not necessary.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myPrintInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">(x myInterface)</span></span> &#123;</span><br><span class="line">	x.(myPrintInterface).<span class="built_in">print</span>() <span class="comment">// type assertion to myPrintInterface</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>x</code> 转换为 <code>myPrintInterface</code> 类型是完全动态的：只要 <code>x</code> 的底层类型（动态类型）定义了 <code>print</code> 方法这个调用就可以正常运行（译注：若 <code>x</code> 的底层类型未定义 <code>print</code> 方法，此处类型断言会导致 <code>panic</code>，最佳实践应该为 <code>if mpi, ok := x.(myPrintInterface); ok &#123; mpi.print() &#125;</code></p>
<h3 id="反射包"><a href="#反射包" class="headerlink" title="反射包"></a>反射包</h3><h4 id="方法和类型的反射"><a href="#方法和类型的反射" class="headerlink" title="方法和类型的反射"></a>方法和类型的反射</h4><p>反射包的 <code>Type</code> 表示一个 Go 类型，反射包的 <code>Value</code> 为 Go 值提供了反射接口</p>
<p><code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code>返回被检查对象的类型和值</p>
<p>实际上，反射是通过检查一个接口的值，变量首先被转换一个空接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反射可以从接口值反射到对象，也可以从对象反射回接口值</p>
<p> <code>Type</code> 和 <code>Value</code> 都有 <code>Kind()</code> 方法返回一个常量来表示类型， <code>Kind()</code> 总是返回底层类型，同样 <code>Value</code> 有叫做 <code>Int()</code> 和 <code>Float()</code> 的方法可以获取存储在内部的值</p>
<p>变量 <code>v</code> 的 <code>Interface()</code> 可以得到还原（接口）值，可以这样打印 <code>v</code> 的值：<code>fmt.Println(v.Interface())</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blog: Laws of Reflection</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;type:&quot;</span>, reflect.TypeOf(x))</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	fmt.Println(<span class="string">&quot;value:&quot;</span>, v)</span><br><span class="line">	fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())</span><br><span class="line">	fmt.Println(<span class="string">&quot;kind:&quot;</span>, v.Kind())</span><br><span class="line">	fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())</span><br><span class="line">	fmt.Println(v.Interface())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value is %5.2e\n&quot;</span>, v.Interface())</span><br><span class="line">	y := v.Interface().(<span class="type">float64</span>)</span><br><span class="line">	fmt.Println(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>: <span class="type">float64</span></span><br><span class="line">value: <span class="number">3.4</span></span><br><span class="line"><span class="keyword">type</span>: <span class="type">float64</span></span><br><span class="line">kind: <span class="type">float64</span></span><br><span class="line">value: <span class="number">3.4</span></span><br><span class="line"><span class="number">3.4</span></span><br><span class="line">value is <span class="number">3.40e+00</span></span><br><span class="line"><span class="number">3.4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="通过反射设置值"><a href="#通过反射设置值" class="headerlink" title="通过反射设置值"></a>通过反射设置值</h4><p>可以使用 <code>CanSet()</code> 方法测试是否可设置反射值，并不是所有的都有该属性</p>
<p>若要将上述<code>v</code>的值设置为<code>3.1415</code>可以小心使用<code>v.SetFloat(3.1415)</code>，但该方法不一定能够成功</p>
<p>可以使用 <code>Elem()</code> 函数，这间接地使用指针：<code>v = v.Elem()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	<span class="comment">// setting a value:</span></span><br><span class="line">	<span class="comment">// v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">	v = reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;type of v:&quot;</span>, v.Type())</span><br><span class="line">	fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">	v = v.Elem()</span><br><span class="line">	fmt.Println(<span class="string">&quot;The Elem of v is: &quot;</span>, v)</span><br><span class="line">	fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">	v.SetFloat(<span class="number">3.1415</span>) <span class="comment">// this works!</span></span><br><span class="line">	fmt.Println(v.Interface())</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">settability of v: <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> of v: *<span class="type">float64</span></span><br><span class="line">settability of v: <span class="literal">false</span></span><br><span class="line">The Elem of v is:  &lt;<span class="type">float64</span> Value&gt;</span><br><span class="line">settability of v: <span class="literal">true</span></span><br><span class="line"><span class="number">3.1415</span></span><br><span class="line">&lt;<span class="type">float64</span> Value&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反射中有些内容是需要用地址去改变它的状态的</p>
<h4 id="反射结构"><a href="#反射结构" class="headerlink" title="反射结构"></a>反射结构</h4><p>有时需要反射一个结构类型。<code>NumField()</code> 方法返回结构内的字段数量；通过一个 <code>for</code> 循环用索引取得每个字段的值 <code>Field(i)</code></p>
<p>可以调用签名在结构上的方法，使用索引 <code>n</code> 来调用：<code>Method(n).Call(nil)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NotknownType <span class="keyword">struct</span> &#123;</span><br><span class="line">	s1, s2, s3 <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NotknownType)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n.s1 + <span class="string">&quot; - &quot;</span> + n.s2 + <span class="string">&quot; - &quot;</span> + n.s3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// variable to investigate:</span></span><br><span class="line"><span class="keyword">var</span> secret <span class="keyword">interface</span>&#123;&#125; = NotknownType&#123;<span class="string">&quot;Ada&quot;</span>, <span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Oberon&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	value := reflect.ValueOf(secret) <span class="comment">// &lt;main.NotknownType Value&gt;</span></span><br><span class="line">	typ := reflect.TypeOf(secret)    <span class="comment">// main.NotknownType</span></span><br><span class="line">	<span class="comment">// alternative:</span></span><br><span class="line">	<span class="comment">// typ := value.Type()  // main.NotknownType</span></span><br><span class="line">	fmt.Println(typ)</span><br><span class="line">	knd := value.Kind() <span class="comment">// struct</span></span><br><span class="line">	fmt.Println(knd)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// iterate through the fields of the struct:</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; value.NumField(); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Field %d: %v\n&quot;</span>, i, value.Field(i))</span><br><span class="line">		<span class="comment">// error: panic: reflect.Value.SetString using value obtained using unexported field</span></span><br><span class="line">		<span class="comment">// value.Field(i).SetString(&quot;C#&quot;)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call the first method, which is String():</span></span><br><span class="line">	results := value.Method(<span class="number">0</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(results) <span class="comment">// [Ada - Go - Oberon]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main.NotknownType</span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">Field <span class="number">0</span>: Ada</span><br><span class="line">Field <span class="number">1</span>: Go</span><br><span class="line">Field <span class="number">2</span>: Oberon</span><br><span class="line">[Ada - Go - Oberon]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是如果尝试更改一个值，会得到一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect.Value.SetString using value obtained using unexported field</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是因为结构中只有被导出字段（首字母大写）才是可设置的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="type">int</span></span><br><span class="line">	B <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := T&#123;<span class="number">23</span>, <span class="string">&quot;skidoo&quot;</span>&#125;</span><br><span class="line">	s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">	typeOfT := s.Type()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">		f := s.Field(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d: %s %s = %v\n&quot;</span>, i,</span><br><span class="line">			typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">	&#125;</span><br><span class="line">	s.Field(<span class="number">0</span>).SetInt(<span class="number">77</span>)</span><br><span class="line">	s.Field(<span class="number">1</span>).SetString(<span class="string">&quot;Sunset Strip&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;t is now&quot;</span>, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: A <span class="type">int</span> = <span class="number">23</span></span><br><span class="line"><span class="number">1</span>: B <span class="type">string</span> = skidoo</span><br><span class="line">t is now &#123;<span class="number">77</span> Sunset Strip&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Printf-和反射"><a href="#Printf-和反射" class="headerlink" title="Printf()和反射"></a>Printf()和反射</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, args ... <span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Printf()</code> 中的 <code>...</code> 参数为空接口类型，它使用反射包来解析这个参数列表，故能够知道它每个参数的类型</p>
<h3 id="解码任意数据"><a href="#解码任意数据" class="headerlink" title="解码任意数据"></a>解码任意数据</h3><p>json 包使用 <code>map[string]interface&#123;&#125;</code> 和 <code>[]interface&#123;&#125;</code> 储存任意的 JSON 对象和数组；其可以被反序列化为任何的 JSON blob 存储到接口值中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b := []<span class="type">byte</span>(<span class="string">`&#123;&quot;Name&quot;: &quot;Wednesday&quot;, &quot;Age&quot;: 6, &quot;Parents&quot;: [&quot;Gomez&quot;, &quot;Morticia&quot;]&#125;`</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal(b, &amp;f)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>f</code>指向的值是一个<code>map</code>，key为字符串，value是自身存储作为空接口类型的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Age&quot;</span>:  <span class="number">6</span>,</span><br><span class="line">	<span class="string">&quot;Parents&quot;</span>: []<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">		<span class="string">&quot;Gomez&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Morticia&quot;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要访问该数据可以使用类型断言</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := f.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">	<span class="keyword">switch</span> vv := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">		fmt.Println(k, <span class="string">&quot;is string&quot;</span>, vv)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		fmt.Println(k, <span class="string">&quot;is int&quot;</span>, vv)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">		fmt.Println(k, <span class="string">&quot;is an array:&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> i, u := <span class="keyword">range</span> vv &#123;</span><br><span class="line">			fmt.Println(i, u)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(k, <span class="string">&quot;is of a type I don’t know how to handle&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过这种方式可以处理未知的 JSON 数据，同时确保类型安全</p>
<h3 id="编码和解码流"><a href="#编码和解码流" class="headerlink" title="编码和解码流"></a>编码和解码流</h3><p><code>json</code> 包提供 <code>Decoder</code> 和 <code>Encoder</code> 类型来支持常用 JSON 数据流读写。<code>NewDecoder()</code> 和 <code>NewEncoder()</code> 分别封装了 <code>io.Reader</code> 和 <code>io.Writer</code> 接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span></span> *Decoder</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEncoder</span><span class="params">(w io.Writer)</span></span> *Encoder</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要想把 JSON 直接写入文件，可以使用 <code>json.NewEncoder</code> 初始化文件（或者任何实现 <code>io.Writer</code> 的类型），并调用 <code>Encode()</code>；反过来与其对应的是使用 <code>json.NewDecoder</code> 和 <code>Decode()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span></span> *Decoder</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dec *Decoder)</span></span> Decode(v <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目标或源数据要能够被编码就必须实现 <code>io.Writer</code> 或 <code>io.Reader</code> 接口。由于 Go 语言中到处都实现了 Reader 和 Writer，因此 <code>Encoder</code> 和 <code>Decoder</code> 应用场景非常广泛，例如读取或写入 HTTP 连接、websockets 或文件</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>计算机程序在运行时，可以访问、检测和修改它本身状态或行为的能力</p>
<p>在reflect包中定义了一个接口和一个结构体，即reflect.Type和reflect.Value结构体，它们提供了很多函数获取存储在接口中的类型信息</p>
<ul>
<li>reflect.Type接口主要提供关于类型相关的信息</li>
<li>reflect.Value结构体主要提供关于值相关的信息，可以获取甚至改变类型的值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TypeOf用于提取一个接口中值的类型信息，实参会先被转化为空接口类型，这样，实参的类型信息、方法集、值信息都存储到interface{}中了；ValueOf()返回一个结构体变量，包含类型信息及实际值</p>
<h4 id="反射的三大法则"><a href="#反射的三大法则" class="headerlink" title="反射的三大法则"></a>反射的三大法则</h4><ul>
<li><p>反射可以将<code>接口类型变量</code>转换为<code>反射类型对象</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">6.8</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>,v.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;Kind is float64:&quot;</span>,v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">&quot;value&quot;</span>,v.Float())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>反射可以将<code>反射类型对象</code>转换为<code>接口类型变量</code></p>
<p>Go中的反射可以创造自己反面类型的对象，一个<code>reflect.Value</code>类型的变量，可以使用<code>Interface()</code>方法恢复其接口类型的值；该方法会将type和value信息打包并填充到一个接口变量中，然后返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y := v.Interface().(<span class="type">float64</span>)</span><br><span class="line">fmt.Println(y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>若要修改<code>反射类型对象</code>，则其值必须是<code>可写的</code></p>
<p>要让反射对象具备可写性需要注意：创建反射对象时传入变量的是指针；使用Elem()方法返回指针指向的数据</p>
<ul>
<li><p>不是接收变量指针创建的反射对象，是不具备可写性的</p>
</li>
<li><p>是否具备可写性，可使用CanSet方法得知</p>
</li>
<li><p>对不具备可写性的对象修改是无意义的，也是不合法的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;Go web&quot;</span></span><br><span class="line"></span><br><span class="line">v1 := reflect.ValueOf(&amp;name)</span><br><span class="line">v2 := v1.Elem()</span><br><span class="line"></span><br><span class="line"><span class="comment">//v1不具有可写性，v2具有可写性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="修改反射对象"><a href="#修改反射对象" class="headerlink" title="修改反射对象"></a>修改反射对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> SetBool(x <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> SetBytes(x []<span class="type">byte</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> SetFloat(x <span class="type">float64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> SetInt(x <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> SetString(x <span class="type">string</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h2><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>标准输入 <code>os.Stdin</code> 和标准输出 <code>os.Stdout</code>的类型都是 <code>*os.File</code>；文件使用指向 <code>os.File</code> 类型的指针表示，也即文件句柄</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inputFile, _ := os.Open(<span class="string">&quot;input.dat&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> inputFile.Close()</span><br><span class="line"></span><br><span class="line">    inputReader := bufio.NewReader(inputFile)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        inputString, readerError := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;The input was: %s&quot;</span>, inputString)</span><br><span class="line">        <span class="keyword">if</span> readerError == io.EOF &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若文件不存在或无权打开文件，则Open函数会返回一个错误：inputFile, inputError = os.Open</span></span><br><span class="line"><span class="comment">//若文件打开正常，则使用defer inputFile.Close()确保程序退出前关闭该文件；然后使用bufio.NewReader()获得一个读取器变量，通过其可以方便地操作相对高层的string对象，避免操作较底层的字节</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> Unix 和 Linux 的行结束符是 <code>\n</code>，而 Windows 的行结束符是 <code>\r\n</code>；在使用 <code>ReadString</code> 和 <code>ReadBytes</code> 方法的时候不用关心操作系统类型，直接使用 <code>\n</code> 即可。另外也可以使用 <code>ReadLine()</code> 方法来实现相同的功能</p>
<p>一旦读取到文件末尾，<code>readerError</code>的值变为常量<code>io.EOF</code></p>
<h5 id="将文件内容读入字符串"><a href="#将文件内容读入字符串" class="headerlink" title="将文件内容读入字符串"></a>将文件内容读入字符串</h5><p>可以使用 <code>io/ioutil</code> 中的 <code>ioutil.ReadFile()</code> 方法，该方法第一个返回值的类型是 <code>[]byte</code>，里面存放读取到的内容，第二个返回值是错误，如果没有错误发生，第二个返回值为 <code>nil</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buf, _ := ioutil.ReadFile(inputFile)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="type">string</span>(buf))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="带缓冲的读取"><a href="#带缓冲的读取" class="headerlink" title="带缓冲的读取"></a>带缓冲的读取</h5><p>有时文件内容不按行划分或为二进制，此时<code>ReadString()</code>无法使用；可以使用<code>bufio.Reader</code>中的<code>Read()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">...</span><br><span class="line">n, err := inputReader.Read(buf)		<span class="comment">//n表示读取到的字节数</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">break</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="按列读取文件数据"><a href="#按列读取文件数据" class="headerlink" title="按列读取文件数据"></a>按列读取文件数据</h5><p>若数据按列排列且用空格分隔，可使用<code>fmt</code>中以<code>FScan...</code>开头的系列函数读取</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">&quot;products2.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> col1, col2, col3 []<span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> v1, v2, v3 <span class="type">string</span></span><br><span class="line">        _, err := fmt.Fscanln(file, &amp;v1, &amp;v2, &amp;v3)</span><br><span class="line">        <span class="comment">// scans until newline</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        col1 = <span class="built_in">append</span>(col1, v1)</span><br><span class="line">        col2 = <span class="built_in">append</span>(col2, v2)</span><br><span class="line">        col3 = <span class="built_in">append</span>(col3, v3)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(col1)</span><br><span class="line">    fmt.Println(col2)</span><br><span class="line">    fmt.Println(col3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ABC FUNC GO]</span><br><span class="line">[40 56 45]</span><br><span class="line">[150 280 356]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// var outputWriter *bufio.Writer</span></span><br><span class="line">	<span class="comment">// var outputFile *os.File</span></span><br><span class="line">	<span class="comment">// var outputError os.Error</span></span><br><span class="line">	<span class="comment">// var outputString string</span></span><br><span class="line">	outputFile, _ := os.OpenFile(<span class="string">&quot;output.dat&quot;</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">defer</span> outputFile.Close()</span><br><span class="line"></span><br><span class="line">	outputWriter := bufio.NewWriter(outputFile)</span><br><span class="line">	outputString := <span class="string">&quot;hello world!\n&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">		outputWriter.WriteString(outputString)</span><br><span class="line">	&#125;</span><br><span class="line">	outputWriter.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>OpenFile</code> 函数有三个参数：文件名、一个或多个标志（使用逻辑运算符 <code>|</code> 连接），使用的文件权限</p>
<ul>
<li><code>os.O_RDONLY</code>：只读  </li>
<li><code>os.O_WRONLY</code>：只写  </li>
<li><code>os.O_CREATE</code>：创建：如果指定文件不存在，就创建该文件 </li>
<li><code>os.O_TRUNC</code>：截断：如果指定文件已存在，就将该文件的长度截为 0</li>
</ul>
<p>在读文件的时候，文件的权限是被忽略的，所以在使用 <code>OpenFile()</code> 时传入的第三个参数可以用 0 。而在写文件时，不管是 Unix 还是 Windows，都需要使用 &#96;</p>
<p>然后创建一个写入器（缓冲区）对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outputWriter := bufio.NewWriter(outputFile)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着用 <code>for</code> 循环写入缓冲区：<code>outputWriter.WriteString(outputString)</code></p>
<p>缓冲区的内容紧接着被完全写入文件：<code>outputWriter.Flush()</code></p>
<p>若写入的东西很简单，可以使用 <code>fmt.Fprintf(outputFile, &quot;Some test data.\n&quot;)</code> 直接将内容写入文件。<code>fmt</code> 包里的 <code>F...</code> 开头的 <code>Print()</code> 函数可以直接写入任何 <code>io.Writer</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用fmt.FPrintf()函数写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	os.Stdout.WriteString(<span class="string">&quot;hello, world\n&quot;</span>)	<span class="comment">//可以输出到屏幕</span></span><br><span class="line">	f, _ := os.OpenFile(<span class="string">&quot;test&quot;</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	f.WriteString(<span class="string">&quot;hello, world in a file\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不使用缓冲区，直接将内容写入文件：f.WriteString()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="XML数据格式"><a href="#XML数据格式" class="headerlink" title="XML数据格式"></a>XML数据格式</h3><p>如同 <code>json</code> 包一样，也有 <code>xml.Marshal()</code> 和 <code>xml.Unmarshal()</code> 从 XML 中编码和解码数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xml.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/xml&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t, token xml.Token</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	input := <span class="string">&quot;&lt;Person&gt;&lt;FirstName&gt;Laura&lt;/FirstName&gt;&lt;LastName&gt;Lynn&lt;/LastName&gt;&lt;/Person&gt;&quot;</span></span><br><span class="line">	inputReader := strings.NewReader(input)</span><br><span class="line">	p := xml.NewDecoder(inputReader)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> t, err = p.Token(); err == <span class="literal">nil</span>; t, err = p.Token() &#123;</span><br><span class="line">		<span class="keyword">switch</span> token := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> xml.StartElement:</span><br><span class="line">			name := token.Name.Local</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Token name: %s\n&quot;</span>, name)</span><br><span class="line">			<span class="keyword">for</span> _, attr := <span class="keyword">range</span> token.Attr &#123;</span><br><span class="line">				attrName := attr.Name.Local</span><br><span class="line">				attrValue := attr.Value</span><br><span class="line">				fmt.Printf(<span class="string">&quot;An attribute is: %s %s\n&quot;</span>, attrName, attrValue)</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> xml.EndElement:</span><br><span class="line">			fmt.Println(<span class="string">&quot;End of token&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> xml.CharData:</span><br><span class="line">			content := <span class="type">string</span>([]<span class="type">byte</span>(token))</span><br><span class="line">			fmt.Printf(<span class="string">&quot;This is the content: %v\n&quot;</span>, content)</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Token name: Person</span><br><span class="line">Token name: FirstName</span><br><span class="line">This is the content: Laura</span><br><span class="line">End of token</span><br><span class="line">Token name: LastName</span><br><span class="line">This is the content: Lynn</span><br><span class="line">End of token</span><br><span class="line">End of token</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>XML 文本被循环处理直到 <code>Token()</code> 返回一个错误，因为已经到达文件尾部，再没有内容可供处理了。通过一个 type-switch 可以根据一些 XML 标签进一步处理。Chardata 中的内容只是一个 <code>[]byte</code>，通过字符串转换让其变得可读性更强</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><p><code>recover()</code>内建函数用于从panic或错误场景中恢复：停止终止过程进而恢复正常执行</p>
<p><code>recover</code> 只能在 <code>defer</code> 修饰的函数中使用：取得 <code>panic()</code> 调用中传递过来的错误值，如果是正常执行，调用 <code>recover()</code> 会返回 <code>nil</code>，且没有其它效果</p>
<p>即<code>panic()</code> 会导致栈被展开直到 <code>defer</code> 修饰的 <code>recover()</code> 被调用或程序中止</p>
<p><code>defer</code>-<code>panic()</code>-<code>recover()</code> 某种意义上也是一种像 <code>if</code>，<code>for</code> 的控制流机制</p>
<h3 id="闭包处理错误"><a href="#闭包处理错误" class="headerlink" title="闭包处理错误"></a>闭包处理错误</h3><p>每当函数返回时，我们应该检查是否有错误发生：但是这会导致重复乏味的代码。结合 defer&#x2F;panic&#x2F;recover 机制和闭包可以得到一个我们马上要讨论的更加优雅的模式。不过这个模式只有当所有的函数都是同一种签名时可用，这样就有相当大的限制。一个很好的使用它的例子是 web 应用，所有的处理函数都是下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler1</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设所有的函数都有这样的签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a type1, b type2)</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数的数量和类型是不相关的。给这个类型一个名字：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fType1 = <span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a type1, b type2)</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在该模式中使用了两个帮助函数：</p>
<p>1）<code>check()</code>：这是用来检查是否有错误和 panic 发生的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(err <span class="type">error</span>)</span></span> &#123; <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="built_in">panic</span>(err) &#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2）<code>errorhandler()</code>：这是一个包装函数。接收一个 <code>fType1</code> 类型的函数 <code>fn</code> 并返回一个调用 <code>fn</code> 的函数。里面就包含有 defer&#x2F;recover 机制</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errorHandler</span><span class="params">(fn fType1)</span></span> fType1 &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(a type1, b type2)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err, ok := <span class="built_in">recover</span>().(<span class="type">error</span>); ok &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;run time panic: %v&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		fn(a, b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当错误发生时会 recover 并打印在日志中；<code>check()</code> 函数会在所有的被调函数中调用，像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(a type1, b type2)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	f, _, err := <span class="comment">// call function/method</span></span><br><span class="line">	check(err)</span><br><span class="line">	t, err := <span class="comment">// call function/method</span></span><br><span class="line">	check(err)</span><br><span class="line">	_, err2 := <span class="comment">// call function/method</span></span><br><span class="line">	check(err2)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过这种机制，所有的错误都会被 recover，并且调用函数后的错误检查代码也被简化为调用 <code>check(err)</code> 即可。在这种模式下，不同的错误处理必须对应不同的函数类型；它们（错误处理）可能被隐藏在错误处理包内部。可选的更加通用的方式是用一个空接口类型的切片作为参数和返回值</p>
<h2 id="协程与通道"><a href="#协程与通道" class="headerlink" title="协程与通道"></a>协程与通道</h2><h3 id="带缓冲通道实现一个信号量"><a href="#带缓冲通道实现一个信号量" class="headerlink" title="带缓冲通道实现一个信号量"></a>带缓冲通道实现一个信号量</h3><p>信号量是实现互斥锁常见的同步机制，限制对资源的访问，解决读写问题；使用带缓冲的通道可以实现：</p>
<ul>
<li>带缓冲通道的容量和同步资源容量相同</li>
<li>通道长度（当前存放元素个数）与当前资源被使用数量相同</li>
<li>容量减去通道长度即未处理资源个数（标准信号量的整数值）</li>
</ul>
<p>创建一个长度可变但容量为0（字节）的通道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> semaphore <span class="keyword">chan</span> Empty</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将可用资源数量<code>N</code>初始化信号量<code>semaphore</code>：<code>sem = make(semaphore,N)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquire n resources</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span></span> P(n <span class="type">int</span>) &#123;</span><br><span class="line">	e := <span class="built_in">new</span>(Empty)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		s &lt;- e</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release n resources</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span></span> V(n <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; n; i++&#123;</span><br><span class="line">		&lt;- s</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现互斥的例子</span></span><br><span class="line"><span class="comment">/* mutexes */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span></span> Lock() &#123;</span><br><span class="line">	s.P(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span></span> Unlock()&#123;</span><br><span class="line">	s.V(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* signal-wait */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span></span> Wait(n <span class="type">int</span>) &#123;</span><br><span class="line">	s.P(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span></span> Signal() &#123;</span><br><span class="line">	s.V(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="任务和worker"><a href="#任务和worker" class="headerlink" title="任务和worker"></a>任务和worker</h3><p>假设需要处理很多任务；一个 worker 处理一项任务。任务可以被定义为一个结构体：</p>
<h4 id="旧模式：使用共享内存进行同步"><a href="#旧模式：使用共享内存进行同步" class="headerlink" title="旧模式：使用共享内存进行同步"></a>旧模式：使用共享内存进行同步</h4><p>由各个任务组成的任务池共享内存；为了同步各个 worker 以及避免资源竞争，需要对任务池进行加锁保护</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    Mu		sync.Mutex</span><br><span class="line">    Tasks	[]*Task</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(pool *Pool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        pool.Mu.Lock()</span><br><span class="line">        <span class="comment">// begin critical section:</span></span><br><span class="line">        task := pool.Tasks[<span class="number">0</span>]        <span class="comment">// take the first task</span></span><br><span class="line">        pool.Tasks = pool.Tasks[<span class="number">1</span>:]  <span class="comment">// update the pool of tasks</span></span><br><span class="line">        <span class="comment">// end critical section</span></span><br><span class="line">        pool.Mu.Unlock()</span><br><span class="line">        process(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加锁保证了同一时间只有一个 go 协程可以进入到 <code>pool</code> 中：一项任务有且只有一个worker；但若任务量较多时，频繁地加锁&#x2F;解锁会导致效率降低</p>
<h4 id="新模式：使用通道"><a href="#新模式：使用通道" class="headerlink" title="新模式：使用通道"></a>新模式：使用通道</h4><p>使用通道进行同步：使用一个通道接受需要处理的任务，一个通道接受处理完成的任务（及其结果）。worker 在协程中启动，其数量 <code>N</code> 应该根据任务数量进行调整；主线程扮演着 Master 节点角色，可能写成如下形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pending, done := <span class="built_in">make</span>(<span class="keyword">chan</span> *Task), <span class="built_in">make</span>(<span class="keyword">chan</span> *Task)</span><br><span class="line">    <span class="keyword">go</span> sendWork(pending)       <span class="comment">// put tasks with work on the channel</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;   <span class="comment">// start N goroutines to do work</span></span><br><span class="line">    	<span class="keyword">go</span> Worker(pending, done)</span><br><span class="line">    &#125;</span><br><span class="line">	consumeWork(done)          <span class="comment">// continue with the processed tasks</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(in,out <span class="keyword">chan</span> *Task)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        t := &lt;-in</span><br><span class="line">        process(t)</span><br><span class="line">        out &lt;- t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="网络及网页应用"><a href="#网络及网页应用" class="headerlink" title="网络及网页应用"></a>网络及网页应用</h2><h3 id="tcp服务器"><a href="#tcp服务器" class="headerlink" title="tcp服务器"></a>tcp服务器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Starting the server ...&quot;</span>)</span><br><span class="line">	<span class="comment">// 创建 listener</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:50000&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error listening&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">//终止程序</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 监听并接受来自客户端的连接</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Error accepting&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">return</span> <span class="comment">// 终止程序</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> doServerStuff(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doServerStuff</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">512</span>)</span><br><span class="line">		<span class="built_in">len</span>, err := conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Error reading&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">return</span> <span class="comment">//终止程序</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Received data: %v&quot;</span>, <span class="type">string</span>(buf[:<span class="built_in">len</span>]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用一个无限 <code>for</code> 循环的 <code>listener.Accept()</code> 来等待客户端的请求。客户端的请求将产生一个 <code>net.Conn</code> 类型的连接变量。然后一个独立的协程使用这个连接执行 <code>doServerStuff()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开连接:</span></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:50000&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//由于目标计算机积极拒绝而无法创建连接</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;Error dialing&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// 终止程序</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">	fmt.Println(<span class="string">&quot;First, what is your name?&quot;</span>)</span><br><span class="line">	clientName, _ := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	<span class="comment">// fmt.Printf(&quot;CLIENTNAME %s&quot;, clientName)</span></span><br><span class="line">	trimmedClient := strings.Trim(clientName, <span class="string">&quot;\r\n&quot;</span>) <span class="comment">// Windows 平台下用 &quot;\r\n&quot;，Linux平台下使用 &quot;\n&quot;</span></span><br><span class="line">	<span class="comment">// 给服务器发送信息直到程序退出：</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;What to send to the server? Type Q to quit.&quot;</span>)</span><br><span class="line">		input, _ := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		trimmedInput := strings.Trim(input, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">		<span class="comment">// fmt.Printf(&quot;input:--%s--&quot;, input)</span></span><br><span class="line">		<span class="comment">// fmt.Printf(&quot;trimmedInput:--%s--&quot;, trimmedInput)</span></span><br><span class="line">		<span class="keyword">if</span> trimmedInput == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		_, err = conn.Write([]<span class="type">byte</span>(trimmedClient + <span class="string">&quot; says: &quot;</span> + trimmedInput))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端通过 <code>net.Dial()</code> 创建了一个和服务器之间的连接，一旦连接到远程系统，函数就会返回一个<code>Conn</code>类型的接口，此时可以用它发送和接收数据</p>
<h3 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h3><p>http描述了网页服务器如何与客户端浏览器进行通信</p>
<p>若<code>req</code>是来自html表单的POST请求，<code>&quot;var1&quot;是表单中一个输入域的名称</code>，则可以通过<code>req.FormValue(&quot;var1&quot;)</code>获取；或者先执行<code>request.ParseForm()</code>，然后再获取<code>request.Form[&quot;var1&quot;]</code>的第一个返回参数</p>
<p><code>var1,found := request.Form[&quot;var1&quot;]</code></p>
<p>若 <code>var1</code> 并未出现在表单中，<code>found</code> 就是 <code>false</code></p>
<p>表单属性实际上是 <code>map[string][]string</code> 类型。网页服务器发送一个 <code>http.Response</code> 响应，它是通过 <code>http.ResponseWriter</code> 对象输出的，后者组装了 HTTP 服务器响应，通过对其写入内容，就将数据发送给了 HTTP 客户端</p>
<p>如何处理请求即是<code>http.HandleFunc()</code>函数完成的</p>
<h4 id="确保网页健壮性"><a href="#确保网页健壮性" class="headerlink" title="确保网页健壮性"></a>确保网页健壮性</h4><p>当网页的处理函数发生 panic，服务器会简单地终止运行，这会造成严重的影响；我们需要网页能够承受突发问题</p>
<p>首先想到的是在每个处理函数中使用<code>defer/recover()</code>，但是这样会产生较多重复代码，使用闭包的错误处理模式是更优雅的方案</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logPanics</span><span class="params">(function HandleFunc)</span></span> HandleFunc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;[%v] caught panic: %v&quot;</span>, request.RemoteAddr, x)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		function(writer, request)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后用<code>logPanics()</code>包装对处理函数的调用，处理函数现在可以恢复panic调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/test1&quot;</span>,logPanics(SimpleServer))</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/test2&quot;</span>,logPanics(FormServer))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> form = <span class="string">`&lt;html&gt;&lt;body&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot; name=&quot;bar&quot;&gt;</span></span><br><span class="line"><span class="string">		&lt;input type=&quot;text&quot; name=&quot;in&quot;/&gt;</span></span><br><span class="line"><span class="string">		&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;</span></span><br><span class="line"><span class="string">	&lt;/form&gt;&lt;/html&gt;&lt;/body&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandleFnc <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* handle a simple get request */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SimpleServer</span><span class="params">(w http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">	io.WriteString(w, <span class="string">&quot;&lt;h1&gt;hello, world&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* handle a form, both the GET which displays the form</span></span><br><span class="line"><span class="comment">   and the POST which processes it.*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormServer</span><span class="params">(w http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">	w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line">	<span class="keyword">switch</span> request.Method &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">		<span class="comment">/* display the form to the user */</span></span><br><span class="line">		io.WriteString(w, form)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">		<span class="comment">/* handle the form data, note that ParseForm must</span></span><br><span class="line"><span class="comment">		   be called before we can extract form data*/</span></span><br><span class="line">		<span class="comment">//request.ParseForm();</span></span><br><span class="line">		<span class="comment">//io.WriteString(w, request.Form[&quot;in&quot;][0])</span></span><br><span class="line">		io.WriteString(w, request.FormValue(<span class="string">&quot;in&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/test1&quot;</span>, logPanics(SimpleServer))</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/test2&quot;</span>, logPanics(FormServer))</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:8088&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logPanics</span><span class="params">(function HandleFnc)</span></span> HandleFnc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;[%v] caught panic: %v&quot;</span>, request.RemoteAddr, x)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		function(writer, request)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="错误和陷阱"><a href="#错误和陷阱" class="headerlink" title="错误和陷阱"></a>错误和陷阱</h2><h3 id="循环中defer"><a href="#循环中defer" class="headerlink" title="循环中defer"></a>循环中defer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">    <span class="keyword">if</span> f, err = os.Open(file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这是错误的方式，当循环结束时文件没有关闭</span></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="comment">// 对文件进行操作</span></span><br><span class="line">    f.Process(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在循环内结尾处的 <code>defer</code> 没有执行，所以文件一直没有关闭，不应该使用<code>defer</code></p>
<p><strong><code>defer</code> 仅在函数返回时才会执行，在循环内的结尾或其他一些有限范围的代码内不会执行</strong></p>
<h3 id="函数参数传递切片"><a href="#函数参数传递切片" class="headerlink" title="函数参数传递切片"></a>函数参数传递切片</h3><p>切片实际是一个指向潜在数组的指针，以切片为参数时只需如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBiggest</span><span class="params">( listOfNumbers []<span class="type">int</span> )</span></span> <span class="type">int</span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>在RPC的应用中一般至少有三种角色：首先是服务端实现RPC方法的开发人员，其次是客户端调用PRC方法的人员，最后是指定服务端和客户端RPC接口规范</p>
<p>将RPC服务接口规范分为三个部分：首先是服务的名字，然后是实现的详细方法列表，最后是注册类型服务的函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HelloServiceName = <span class="string">&quot;path/to/pkg.HelloService&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloServiceInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello(request <span class="type">string</span>, reply *<span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHelloService</span><span class="params">(svc HelloServiceInterface)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rpc.RegisterName(HelloServiceName, svc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改字符串中的一个字符</span></span><br><span class="line">src := <span class="string">&quot;hello&quot;</span></span><br><span class="line">c := []<span class="type">byte</span>(str)</span><br><span class="line">c[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">s2 := <span class="type">string</span>(c)		<span class="comment">//s2 == &quot;cello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字符串的子串</span></span><br><span class="line">substr := str[n:m]</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历字符串</span></span><br><span class="line"><span class="comment">// gives only the bytes:</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">… = str[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gives the Unicode characters:</span></span><br><span class="line"><span class="keyword">for</span> ix, ch := <span class="keyword">range</span> str &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个字符串的字节数</span></span><br><span class="line"><span class="built_in">len</span>(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个字符串的字符数</span></span><br><span class="line">utf8.RuneCountInString(str)	<span class="comment">//len([]rune(str))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何连接字符串(bytes.Buffer/Strings.Join()/+=)</span></span><br><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s,ok := getNextString(); ok &#123;</span><br><span class="line">        buffer.WriteString(s)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(buffer.String(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数组和切片-1"><a href="#数组和切片-1" class="headerlink" title="数组和切片"></a>数组和切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建（分配内存，未初始化）</span></span><br><span class="line">arr1 := <span class="built_in">new</span>([<span class="built_in">len</span>]<span class="keyword">type</span>)</span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>,<span class="built_in">len</span>)</span><br><span class="line"><span class="comment">//初始化（赋值）</span></span><br><span class="line">arr1 := [...]<span class="keyword">type</span>&#123;i1,i2,i3,i4,i5&#125;</span><br><span class="line">arrKeyValue := [<span class="built_in">len</span>]<span class="keyword">type</span>&#123;i1:val1,i2:val2&#125;</span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = arr1[start:end]</span><br><span class="line"><span class="comment">//appendInt实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(x []<span class="type">int</span>,y <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> z []<span class="type">int</span></span><br><span class="line">    zlen := <span class="built_in">len</span>(x) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> zlen &lt;= <span class="built_in">cap</span>(x) &#123;</span><br><span class="line">        z = x[:zlen]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zcap := zlen</span><br><span class="line">        <span class="keyword">if</span> zcap &lt; <span class="number">2</span>*<span class="built_in">len</span>(x) &#123;</span><br><span class="line">            zcap = <span class="number">2</span> * <span class="built_in">len</span>(x)</span><br><span class="line">        &#125;</span><br><span class="line">        z = <span class="built_in">make</span>([]<span class="type">int</span>,zlen,zcap)</span><br><span class="line">        <span class="built_in">copy</span>(z,x)</span><br><span class="line">    &#125;</span><br><span class="line">    z[<span class="built_in">len</span>(x)] = y</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line">map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[keytype]valuetype)</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">map1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>:<span class="number">1</span>,<span class="string">&quot;two&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">//检测key1是否存在</span></span><br><span class="line">val1,isPresent = map1[key1]</span><br><span class="line"><span class="comment">//在映射中删除一个键</span></span><br><span class="line"><span class="built_in">delete</span>(map1,key1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测一个值v是否实现了接口Stringer</span></span><br><span class="line"><span class="keyword">if</span> v, ok := v.(Stringer); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;implements String(): %s\n&quot;</span>, v.String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用接口实现一个类型分类函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">classifier</span><span class="params">(items ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> items &#123;</span><br><span class="line">        <span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;param #%d is a bool\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;param #%d is a float64\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">int</span>, <span class="type">int64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;param #%d is an int\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;param #%d is nil\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;param #%d is a string\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;param #%d’s type is unknown\n&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内建函数recover()终止panic()过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protect</span><span class="params">(g <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	log.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">        	log.Printf(<span class="string">&quot;run time panic: %v&quot;</span>, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    log.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    g()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开一个文件并读取</span></span><br><span class="line">file,err := os.Open(<span class="string">&quot;input.dat&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;An error occurred on opening the inputfile\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;Does the file exist?\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;Have you got acces to it?\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.<span class="built_in">close</span>()</span><br><span class="line">iReader :+ bufio.NewReader(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	str, err := iReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="comment">// error or EOF</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The input was: %s&quot;</span>, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过切片读写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(f *file.File)</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> NBUF = <span class="number">512</span></span><br><span class="line">    <span class="keyword">var</span> buf [NBUF]<span class="type">byte</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> nr, er := f.Read(buf[:]); <span class="literal">true</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> nr &lt; <span class="number">0</span>:</span><br><span class="line">            	fmt.Fprintf(os.Stderr, <span class="string">&quot;cat: error reading from %s: %s\n&quot;</span>,f.String(), er.String())</span><br><span class="line">      			os.Exit(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">case</span> nr == <span class="number">0</span>:</span><br><span class="line">            	<span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> nr &gt; <span class="number">0</span>:</span><br><span class="line">            	<span class="keyword">if</span> nw, ew := file.Stdout.Write(buf[<span class="number">0</span>:nr]); nw != nr &#123;</span><br><span class="line">        			fmt.Fprintf(os.Stderr, <span class="string">&quot;cat: error writing from %s: %s\n&quot;</span>,f.String(), ew.String())</span><br><span class="line">      			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="协程与通道-1"><a href="#协程与通道-1" class="headerlink" title="协程与通道"></a>协程与通道</h3><p>在协程内部完成的工作量，必须远远高于协程的创建和相互来回通信的开销</p>
<ul>
<li><p>出于性能考虑建议使用带缓存的通道：</p>
<p>使用带缓存的通道可以轻易提高它的吞吐量，通过调整通道的容量，甚至可以尝试着更进一步的优化其性能</p>
</li>
<li><p>限制一个通道的数据数量并将它们封装成一个数组：</p>
<p>如果使用通道传递大量单独的数据，那么通道将变成性能瓶颈。然而，将数据块打包封装成数组，在接收端解压数据时性能可以提高</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个带缓存的通道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>,buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历一个通道</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    <span class="comment">// do something with v</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测一个通道是否关闭</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> input,open := &lt;-ch; !open &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s&quot;</span>, input)</span><br><span class="line">&#125;		<span class="comment">//或者遍历通道检测</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过通道让主程序等待，直到协程完成（信号量模式）</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line">doSomethingElseForAWhile()</span><br><span class="line">&lt;-ch	<span class="comment">//若希望程序一直阻塞，在匿名函数中省略ch &lt;- 1即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通道的工厂模版</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pump</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i++ &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//终止一个协程</span></span><br><span class="line">runtime.Goexit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="URL映射应用"><a href="#URL映射应用" class="headerlink" title="URL映射应用"></a>URL映射应用</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>变量 <code>URLStore</code> 是中心化的内存存储，当收到很多 <code>Redirect</code> 服务的请求时，这些请求只涉及读操作：以给定的短 URL 作为键，返回对应的长 URL 的值。然而，对 <code>Add</code> 服务的请求则大不相同，它们会更改 <code>URLStore</code>，添加新的键值对。当在瞬间收到大量更新请求时，可能会产生如下问题：添加操作可能被另一个同类请求打断，写入的长 URL 值可能会丢失；另外，读取和更改同时进行，导致可能读到脏数据。 <code>map</code> 并不保证当开始更新数据时，会彻底阻止另一个更新操作的启动，即<code>map</code> 不是线程安全的，要使线程安全最经典的方法是为其增加一个锁</p>
<p>将<code>URLStore</code>定义为一个结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">type</span> URLStore <span class="keyword">struct</span> &#123;</span><br><span class="line">	urls <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>		<span class="comment">// map from short to long URLs</span></span><br><span class="line">	mu sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *URLStore)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">    s.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> s.mu.RUnlock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s.urls[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *URLStore)</span></span> Set(key,url <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    s.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">    _,present := s.urls[key]</span><br><span class="line">    <span class="keyword">if</span> present &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	s.urls[key] = url</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="URLStore工厂函数"><a href="#URLStore工厂函数" class="headerlink" title="URLStore工厂函数"></a>URLStore工厂函数</h4><p><code>URLStore()</code>结构体中包含<code>map</code>类型的字段，使用前需<code>make()</code>初始化；在Go中创建一个结构体实例，一般通过定义一个前缀<code>New</code>（其中锁无需指明初始化）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewURLStore</span><span class="params">()</span></span> *URLStore &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;URLStore&#123; urls: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="不考虑并发安全"><a href="#不考虑并发安全" class="headerlink" title="不考虑并发安全"></a>不考虑并发安全</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *singleton &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述情况中，多个goroutine可执行第一个检查，使得创建的<code>singleton</code>类型的实例相互覆盖，无法保证返回哪个实例</p>
<p>如果有代码保留了对该实例的引用，可能存在具有不同状态的该类型的多个实例</p>
<h4 id="激进的加锁"><a href="#激进的加锁" class="headerlink" title="激进的加锁"></a>激进的加锁</h4><p>对上述问题加锁能够解决并发安全的问题，但是会使得并发调用变成串行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu Sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *singleton &#123;</span><br><span class="line">    mu.Lock()                    <span class="comment">// 如果实例存在没有必要加锁</span></span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Check-Lock-Check模式"><a href="#Check-Lock-Check模式" class="headerlink" title="Check-Lock-Check模式"></a>Check-Lock-Check模式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 在这里执行加锁安全的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先进行检查，因为if语句的开销比加锁小，其次，进行等待并获取互斥锁，此时在同一时刻只有一个执行，但是，在第一次检查和获取互斥锁之间可能有其他goroutine获取了锁，故在锁的内部需再次检查</p>
<p>因此改进后的<code>GetInstance()</code>方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *singleton &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;	<span class="comment">//不太完美，因为这里不是完全原子的</span></span><br><span class="line">        mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">            instance = &amp;singleton&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过使用<code>sync/atomic</code>包，可以原子化加载并设置一个标志，该标志表明是否已初始化实例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initialized <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *singleton &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUint32(&amp;initialized) == <span class="number">1</span> &#123;	<span class="comment">// 原子操作</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> initialized == <span class="number">0</span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">        atomic.StoreUnit32(&amp;initialized,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Go惯用的单例模式"><a href="#Go惯用的单例模式" class="headerlink" title="Go惯用的单例模式"></a>Go惯用的单例模式</h4><p>在标准库<code>sync</code>中有<code>Once</code>类型，它能保证某个操作只执行一次</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    done <span class="type">uint32</span></span><br><span class="line">    m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123; <span class="comment">// check</span></span><br><span class="line">        o.doSlow(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> doSlow(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">    o.m.Lock()                          <span class="comment">// lock</span></span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> o.done == <span class="number">0</span> &#123;                    <span class="comment">// check</span></span><br><span class="line">        <span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此可以利用<code>sync.Once</code>类型同步对<code>GetInstance()</code>的访问，并确保类型仅被初始化一次</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *singleton &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>sync.Once</code>包是安全地实现此目标的首选方式，类似于Objective-C和Swift（Cocoa）实现<code>dispatch_once</code>方法来执行类似的初始化</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://danyfd.github.io">dany</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://danyfd.github.io/2023/10/13/go%E7%AC%94%E8%AE%B0/">https://danyfd.github.io/2023/10/13/go%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://danyfd.github.io" target="_blank">dany's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/go/">go</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dany</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E4%B9%89"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">字符串的转义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">字符串的修改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.2.1.</span> <span class="toc-text">函数的参数和返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">命名返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">传递变长参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer%E5%92%8C%E8%BF%BD%E8%B8%AA"><span class="toc-number">1.2.2.</span> <span class="toc-text">defer和追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8defer%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">使用defer实现代码追踪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-defer-%E8%AF%AD%E5%8F%A5%E8%AE%B0%E5%BD%95%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">使用 defer 语句记录函数的参数与返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">内置函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">1.2.4.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E9%97%AD%E5%8C%85%EF%BC%9A%E5%B0%86%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">应用闭包：将参数作为返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.1.1.</span> <span class="toc-text">工厂函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E8%B0%83%E8%AF%95"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">使用闭包调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">通过内存缓存提升性能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87"><span class="toc-number">1.3.</span> <span class="toc-text">数组和切片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">切片</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87"><span class="toc-number">1.3.0.2.1.</span> <span class="toc-text">创建切片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="toc-number">1.3.0.2.2.</span> <span class="toc-text">切片的扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.0.2.2.1.</span> <span class="toc-text">扩容函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.0.2.2.2.</span> <span class="toc-text">扩容原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#go%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E5%80%8D"><span class="toc-number">1.3.0.2.2.3.</span> <span class="toc-text">go切片扩容为什么是2倍</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E5%88%87%E7%89%87"><span class="toc-number">1.3.0.2.3.</span> <span class="toc-text">多维切片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bytes%E5%8C%85"><span class="toc-number">1.3.0.2.4.</span> <span class="toc-text">bytes包</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#buffer%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.0.2.4.1.</span> <span class="toc-text">buffer定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E8%BF%87buffer%E4%B8%B2%E8%81%94%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.3.0.2.4.2.</span> <span class="toc-text">通过buffer串联字符串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E5%92%8Cmake-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">new()和make()的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-range%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">for-range结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E9%87%8D%E7%BB%84"><span class="toc-number">1.3.0.5.</span> <span class="toc-text">切片重组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%BF%BD%E5%8A%A0"><span class="toc-number">1.3.0.6.</span> <span class="toc-text">切片的复制与追加</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#append"><span class="toc-number">1.3.0.6.1.</span> <span class="toc-text">append</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#append%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.0.6.1.1.</span> <span class="toc-text">append常见操作</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#copy"><span class="toc-number">1.3.0.6.2.</span> <span class="toc-text">copy</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%94%9F%E6%88%90%E5%AD%97%E8%8A%82%E5%88%87%E7%89%87"><span class="toc-number">1.3.0.7.</span> <span class="toc-text">字符串生成字节切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.0.8.</span> <span class="toc-text">字符串和切片的内存结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="toc-number">1.3.0.9.</span> <span class="toc-text">修改字符串的某个字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E5%AF%B9%E6%AF%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.0.10.</span> <span class="toc-text">字节数组对比函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%8F%8A%E6%8E%92%E5%BA%8F%E5%88%87%E7%89%87%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.0.11.</span> <span class="toc-text">搜索及排序切片和数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.0.12.</span> <span class="toc-text">切片和垃圾回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">1.4.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E5%AF%B9%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.1.</span> <span class="toc-text">键值对元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%87%E7%89%87"><span class="toc-number">1.4.2.</span> <span class="toc-text">map类型的切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86map%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E8%B0%83"><span class="toc-number">1.4.3.</span> <span class="toc-text">将map的键值对调</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">结构体和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">工厂方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">强制使用工厂方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E8%A7%84%E5%88%99"><span class="toc-number">1.5.1.1.1.</span> <span class="toc-text">可见性规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%B5%8C%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">1.5.2.</span> <span class="toc-text">内嵌结构体和匿名字段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">命名冲突</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.1.</span> <span class="toc-text">接口嵌套接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">1.6.2.</span> <span class="toc-text">类型断言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Type-Switch"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">Type Switch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8Sorter%E6%8E%A5%E5%8F%A3%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.3.</span> <span class="toc-text">接口实例：使用Sorter接口排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.4.</span> <span class="toc-text">空接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">构建通用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.4.1.1.</span> <span class="toc-text">通用类型节点数据结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E5%88%87%E7%89%87%E8%87%B3%E7%A9%BA%E6%8E%A5%E5%8F%A3%E5%88%87%E7%89%87"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">复制数据切片至空接口切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%88%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">接口到接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%8C%85"><span class="toc-number">1.6.5.</span> <span class="toc-text">反射包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%8D%E5%B0%84"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">方法和类型的反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AE%BE%E7%BD%AE%E5%80%BC"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">通过反射设置值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">反射结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Printf-%E5%92%8C%E5%8F%8D%E5%B0%84"><span class="toc-number">1.6.5.4.</span> <span class="toc-text">Printf()和反射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E4%BB%BB%E6%84%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">1.6.6.</span> <span class="toc-text">解码任意数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E6%B5%81"><span class="toc-number">1.6.7.</span> <span class="toc-text">编码和解码流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.7.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%89%E5%A4%A7%E6%B3%95%E5%88%99"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">反射的三大法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%8F%8D%E5%B0%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">修改反射对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.</span> <span class="toc-text">读写数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">1.8.1.</span> <span class="toc-text">文件读写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">读文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%AF%BB%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.8.1.1.1.</span> <span class="toc-text">将文件内容读入字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-number">1.8.1.1.2.</span> <span class="toc-text">带缓冲的读取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E5%88%97%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.1.1.3.</span> <span class="toc-text">按列读取文件数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">写文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.8.2.</span> <span class="toc-text">XML数据格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.9.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#recover"><span class="toc-number">1.9.1.</span> <span class="toc-text">recover</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-number">1.9.2.</span> <span class="toc-text">闭包处理错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93"><span class="toc-number">1.10.</span> <span class="toc-text">协程与通道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.10.1.</span> <span class="toc-text">带缓冲通道实现一个信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%92%8Cworker"><span class="toc-number">1.10.2.</span> <span class="toc-text">任务和worker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A7%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">旧模式：使用共享内存进行同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%80%9A%E9%81%93"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">新模式：使用通道</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8F%8A%E7%BD%91%E9%A1%B5%E5%BA%94%E7%94%A8"><span class="toc-number">1.11.</span> <span class="toc-text">网络及网页应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.11.1.</span> <span class="toc-text">tcp服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.11.2.</span> <span class="toc-text">web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E4%BF%9D%E7%BD%91%E9%A1%B5%E5%81%A5%E5%A3%AE%E6%80%A7"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">确保网页健壮性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%92%8C%E9%99%B7%E9%98%B1"><span class="toc-number">2.1.</span> <span class="toc-text">错误和陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%ADdefer"><span class="toc-number">2.1.1.</span> <span class="toc-text">循环中defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%88%87%E7%89%87"><span class="toc-number">2.1.2.</span> <span class="toc-text">函数参数传递切片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC"><span class="toc-number">2.2.1.</span> <span class="toc-text">RPC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5"><span class="toc-number">2.3.</span> <span class="toc-text">代码片段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">数组和切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84"><span class="toc-number">2.3.3.</span> <span class="toc-text">映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-1"><span class="toc-number">2.3.4.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-1"><span class="toc-number">2.3.5.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.6.</span> <span class="toc-text">文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93-1"><span class="toc-number">2.3.7.</span> <span class="toc-text">协程与通道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL%E6%98%A0%E5%B0%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">URL映射应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#URLStore%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">URLStore工厂函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%94%E8%AE%B0"><span class="toc-number">3.</span> <span class="toc-text">笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="toc-number">3.1.1.</span> <span class="toc-text">常见错误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%80%83%E8%99%91%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">不考虑并发安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BF%80%E8%BF%9B%E7%9A%84%E5%8A%A0%E9%94%81"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">激进的加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Check-Lock-Check%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">Check-Lock-Check模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Go%E6%83%AF%E7%94%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">Go惯用的单例模式</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/13/go%E7%AC%94%E8%AE%B0/" title="go笔记">go笔记</a><time datetime="2023-10-13T10:55:49.000Z" title="发表于 2023-10-13 18:55:49">2023-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/13/butterfly%E4%B8%BB%E9%A2%98%E6%89%A9%E5%B1%95/" title="butterfly主题扩展">butterfly主题扩展</a><time datetime="2023-10-13T10:55:38.000Z" title="发表于 2023-10-13 18:55:38">2023-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/13/7z%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/" title="7z工具安装使用">7z工具安装使用</a><time datetime="2023-10-13T10:55:28.000Z" title="发表于 2023-10-13 18:55:28">2023-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/13/docker%E7%AC%94%E8%AE%B0/" title="docker笔记">docker笔记</a><time datetime="2023-10-13T10:53:37.000Z" title="发表于 2023-10-13 18:53:37">2023-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/13/markdown%E7%AC%94%E8%AE%B0/" title="markdown语法笔记">markdown语法笔记</a><time datetime="2023-10-13T10:49:21.000Z" title="发表于 2023-10-13 18:49:21">2023-10-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By dany</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/js/jquery.js"></script><script src="/js/foot.js"></script><div class="aplayer no-destroy" data-id="8798117783" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script id="canvas_nest" defer="defer" color="127,255,212" opacity="0.8" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>